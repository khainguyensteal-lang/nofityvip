-- âš™ï¸ CONFIG
getgenv().webhookHigh = "https://discord.com/api/webhooks/1437692404852326470/NFlZXR30IYzFWo4EgMCduyKyMBT17ZOisOzGVumwBgDJO7bwbVdGebvAnUAenYb7AEZf"
getgenv().webhookLow  = "https://discord.com/api/webhooks/1437692539288293448/DTi1ih3-AiGpEw3lQ26jU9y6udkbq3S-Z0eNmJShk5HNr2332i1VXwlNb9LbE8EHeE2C"
getgenv().HighMin = 10_000_000
getgenv().LowMin  = 1_000_000
getgenv().LowMax  = 10_000_000

-- Náº¿u muá»‘n Ã©p luÃ´n quÃ©t báº¥t ká»ƒ detect: true = quÃ©t, false = tÃ´n detect
getgenv().ForceScan = nil        -- nil = khÃ´ng Ã©p; true = Ã©p quÃ©t; false = Ã©p skip

local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

-- ---------------------------
-- Helper: pretty log with timestamp
-- ---------------------------
local function ts() return "[" .. os.date("%H:%M:%S") .. "]" end
local function debugPrint(...) print(ts(), ...) end
local function debugWarn(...) warn(ts(), ...) end

-- ---------------------------
-- Heuristics: collect diagnostic info
-- ---------------------------
local function getDiagnostics()
    local diag = {}
    diag.jobId = tostring(game.JobId or "")
    diag.privateOk, diag.privateId = pcall(function() return game.PrivateServerId end)
    diag.vipOk, diag.vipId = pcall(function() return game.VIPServerId end)
    diag.plrCount = #Players:GetPlayers()
    diag.maxPlayers = Players.MaxPlayers
    diag.playerNames = {}
    for i,p in ipairs(Players:GetPlayers()) do table.insert(diag.playerNames, p.Name) end
    diag.envClass = (typeof(game.PrivateServerId or "") == "string") and "string" or typeof(game.PrivateServerId)
    return diag
end

-- ---------------------------
-- Heuristics: helpers
-- ---------------------------
local function looksLikeUUID(s)
    if not s or s == "" then return false end
    -- basic UUID-ish pattern (hex + hyphens)
    return s:match("^[%x]+%-%x+%-%x+%-%x+%-%x+$") ~= nil
end

local function looksLikeAllHex(s)
    if not s or s == "" then return false end
    return s:match("^[%x%-]+$") ~= nil
end

-- ---------------------------
-- Detection: combine heuristics
-- ---------------------------
local function detectPrivate()
    local diag = getDiagnostics()
    debugPrint("DIAG jobId:", diag.jobId)
    debugPrint("DIAG privateOk:", diag.privateOk, "privateId:", tostring(diag.privateId))
    debugPrint("DIAG vipOk:", diag.vipOk, "vipId:", tostring(diag.vipId))
    debugPrint("DIAG playerCount:", diag.plrCount, "maxPlayers:", diag.maxPlayers)
    debugPrint("DIAG playerNames:", table.concat(diag.playerNames, ", "))
    debugPrint("DIAG envClass for PrivateServerId:", diag.envClass)

    -- direct checks (most reliable)
    if diag.vipOk and diag.vipId and diag.vipId ~= "" then
        return true, "VIPServerId non-empty"
    end
    if diag.privateOk and diag.privateId and diag.privateId ~= "" and diag.privateId ~= "00000000-0000-0000-0000-000000000000" then
        return true, "PrivateServerId non-empty"
    end

    -- fallback heuristics
    local heur_private = false
    local reasons = {}

    -- 1) if jobId empty -> ambiguous (could be teleport not finished) -> not classify as private
    if diag.jobId == "" then
        table.insert(reasons, "JobId empty (ambiguous)")
    else
        if looksLikeUUID(diag.jobId) then
            table.insert(reasons, "JobId looks like UUID")
            -- if JobId looks like UUID AND very low player count AND small MaxPlayers => likely private
            if diag.plrCount <= 1 and diag.maxPlayers <= 6 then
                heur_private = true
                table.insert(reasons, "JobId UUID + plr<=1 + maxPlayers<=6")
            else
                -- If JobId UUID but enough players, probably public
                table.insert(reasons, "JobId UUID but playerCount>1 => uncertain")
            end
        elseif looksLikeAllHex(diag.jobId) then
            table.insert(reasons, "JobId all-hex pattern")
        else
            table.insert(reasons, "JobId not UUID-like")
        end
    end

    -- 2) Very small MaxPlayers (1-2) strongly indicates private
    if diag.maxPlayers <= 2 then
        heur_private = true
        table.insert(reasons, "MaxPlayers <= 2")
    end

    -- 3) If only one player and JobId looks private-ish -> lean private
    if diag.plrCount == 1 and looksLikeUUID(diag.jobId) then
        heur_private = true
        table.insert(reasons, "Single player + JobId UUID")
    end

    -- Decide final
    if heur_private then
        return true, table.concat(reasons, "; ")
    else
        -- ambiguous vs public: if none heuristics flagged private, treat as public
        return false, table.concat(reasons, "; ")
    end
end

-- ---------------------------
-- Decide action with ForceScan and ambiguity handling
-- ---------------------------
local isPrivate, reason = detectPrivate()
debugPrint("Detection result:", isPrivate and "PRIVATE" or "PUBLIC", "reason:", reason)

if getgenv().ForceScan == true then
    debugPrint("ForceScan=true â†’ Ignoring detection, WILL SCAN (FORCED).")
    isPrivate = false
elseif getgenv().ForceScan == false then
    debugWarn("ForceScan=false â†’ Forcing skip regardless of detection.")
    isPrivate = true
end

-- If ambiguous (reason contains "ambiguous" or reason length small) -> mark UNVERIFIED but continue
local ambiguous = false
if (not isPrivate) and (reason:match("ambiguous") or reason == "" or reason:match("uncertain")) then
    ambiguous = true
    debugWarn("Ambiguous detection (continue but mark UNVERIFIED):", reason)
end

if isPrivate and not ambiguous then
    debugWarn("Final decision: SKIP scanning (private). Reason:", reason)
    return
end

if isPrivate and ambiguous then
    -- private but ambiguous? (rare) -> skip
    debugWarn("Final decision: SKIP scanning (private but ambiguous). Reason:", reason)
    return
end

-- If here: scanning allowed (either public OR ambiguous-unverified allowed)
debugPrint("Proceeding with scanning. UNVERIFIED flag:", ambiguous and "YES" or "NO")

-- ---------------------------
-- Utilities (color, parse money, text)
-- ---------------------------
local lastColor = nil
local function getRandomColor()
    local color
    repeat
        local r, g, b = math.random(0,255), math.random(0,255), math.random(0,255)
        color = bit32.lshift(r,16) + bit32.lshift(g,8) + b
    until color ~= lastColor
    lastColor = color
    return color
end

local function parseMoney(str)
    if not str or str == "" then return 0 end
    local num, suffix = str:match("([%d%.]+)%s*([KMBT]?)")
    num = tonumber(num)
    if not num then return 0 end
    local mult = ({ K=1e3, M=1e6, B=1e9, T=1e12 })[ (suffix and tostring(suffix):upper()) or "" ] or 1
    return num * mult
end

local function getPlotOwner(plot)
    local sign = plot:FindFirstChild("PlotSign")
    if sign and sign:FindFirstChild("SurfaceGui") then
        local frame = sign.SurfaceGui:FindFirstChild("Frame")
        if frame and frame:FindFirstChild("TextLabel") then
            return tostring(frame.TextLabel.Text)
        end
    end
    return "Unknown Owner"
end

local function getObjectText(obj)
    if not obj then return nil end
    if obj:IsA("TextLabel") or obj:IsA("TextButton") or obj:IsA("TextBox") then
        return obj.Text
    elseif obj:IsA("StringValue") or obj:IsA("IntValue") or obj:IsA("NumberValue") then
        return obj.Value
    else
        return obj.Name
    end
end

local function scanPets(plot)
    local pets = {}
    local owner = getPlotOwner(plot)
    for _, obj in ipairs(plot:GetDescendants()) do
        local display, gen
        for _, child in ipairs(obj:GetDescendants()) do
            local n = child.Name:lower()
            if n:match("displayname") or n:match("display") then
                display = child
            elseif n:match("generation") or n:match("gen") then
                gen = child
            end
        end

        if display and gen then
            local nameText = getObjectText(display) or "???"
            local genText = getObjectText(gen) or "$???/s"
            local value = parseMoney(genText)

            table.insert(pets, {
                name = nameText,
                gen = genText,
                value = value,
                owner = owner
            })
        end
    end
    return pets
end

local function sendWebhook(pets, webhookURL, label)
    if #pets == 0 or not webhookURL then return end

    local owner = pets[1].owner or "Unknown Owner"
    local lines = {}
    for _, pet in ipairs(pets) do
        table.insert(lines, string.format("â€¢ %s [**%s**]", pet.name, pet.gen))
    end
    local petBlock = table.concat(lines, "\n")

    local joinLink = string.format(
        "https://chillihub1.github.io/chillihub-joiner/?placeId=%d&gameInstanceId=%s",
        game.PlaceId, game.JobId
    )

    local tpScript = string.format(
        "game:GetService('TeleportService'):TeleportToPlaceInstance(%d, '%s', game.Players.LocalPlayer)",
        game.PlaceId, game.JobId
    )

    local extraNote = ""
    if ambiguous then extraNote = "\n\nâš ï¸ **UNVERIFIED**: server type ambiguous (heuristics uncertain). Results may be from a private/reserved server." end
    local embed = {
        username = "ğŸ›°ï¸ ğƒğğ§ğŠğšğ¢",
        embeds = {{
            title = "**" .. label .. " | ğƒğğ§ğŠğšğ¢ ğğ¨ğ­ğ¢ğŸğ²**" .. (ambiguous and " (UNVERIFIED)" or ""),
            description = string.format(
                "ğŸ” **ğ…ğ¨ğ®ğ§ğ %d ğğğ­ğ¬!** | ğŸ‘¤ **ğğ°ğ§ğğ«:** %s\n\n%s\n\nğŸ‘¥ **ğğ¥ğšğ²ğğ«ğ¬**\n%d / %d\nğŸ†” **ğ‰ğ¨ğ›ğˆğƒ**\n%s\nğŸŒ **ğ‰ğ¨ğ¢ğ§ ğ‹ğ¢ğ§ğ¤**\n[ğ‚ğ¥ğ¢ğœğ¤ ğ­ğ¨ ğ‰ğ¨ğ¢ğ§](%s)\n\n%s%s\nğŸ“œ **ğ“ğğ¥ğğ©ğ¨ğ«ğ­**\n```lua\n%s\n```",
                #pets, owner, petBlock, #Players:GetPlayers(), Players.MaxPlayers, game.JobId, joinLink,
                (ambiguous and ("âš ï¸ **UNVERIFIED DETECTION REASON:** " .. reason .. "\n") or ""), extraNote, tpScript
            ),
            color = getRandomColor(),
            footer = { text = "ğŒğšğğ ğ›ğ² ğŠğ¡ğšğ¢ğ§ğ ğ®ğ²ğğ§" },
            timestamp = DateTime.now():ToIsoDate()
        }}
    }

    local json = HttpService:JSONEncode(embed)
    local req = http_request or request or (syn and syn.request) or (http and http.request)
    if not req then return end

    pcall(function()
        req({
            Url = webhookURL,
            Method = "POST",
            Headers = { ["Content-Type"] = "application/json" },
            Body = json
        })
    end)
end

-- ---------------------------
-- Main scanning loop
-- ---------------------------
local sent = {}
task.spawn(function()
    while true do
        for _, plot in pairs(Workspace.Plots:GetChildren()) do
            local allPets = scanPets(plot)
            local high, low = {}, {}

            for _, pet in ipairs(allPets) do
                local id = pet.name .. "|" .. pet.gen .. "|" .. pet.owner
                if not sent[id] then
                    if pet.value >= getgenv().HighMin then
                        table.insert(high, pet)
                        sent[id] = true
                    elseif pet.value >= getgenv().LowMin and pet.value <= getgenv().LowMax then
                        table.insert(low, pet)
                        sent[id] = true
                    end
                end
            end

            if #high > 0 then sendWebhook(high, getgenv().webhookHigh, "ğŸğŸ-ğŸğŸğŸğ¦") end
            if #low > 0 then sendWebhook(low, getgenv().webhookLow, "ğŸ-ğŸğŸğ¦") end
        end
        task.wait(1)
    end
end)
